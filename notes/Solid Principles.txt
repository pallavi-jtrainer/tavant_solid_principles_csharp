Day 1
OOP 
-> made software design more modular, reusable, aligned with real - world entities

SOLID Principles:
5 specific design guidelines
1. Single Responsibility
2. Open - Closed
3. Liskov Substitution
4. Interface Segregation
5. Dependency Inversion

-----------------------
OOP + SOLID = avoid code smells and technical debt

Technical Debt
1. intentional
2. unintentional
3. bit rot

---------------------------------------------------------
1. Duplicate Code  -> Donot Repeat Yourself(DRY)
2. God Class -> SRP 
3. Comment smell -> Clean code naming -> Cohesion
4. Logic in the wrong class (Feature Envy)

--------------------------------------------------------
Single Responsibility Principle:
-> each class, method, module should do only one work and should do it perfectly
------------------------------------------------------------
Case Study Requirements:
1. Member can borrow a book based on its availability
2. A book can be added provided the isbn is unique
3. book status has to be updated based on whether it is borrowed or returned
4. due date should be 7 days from the date of loan
5. loan amount has to be calculated based on Rs.20 per extra day
6. Member can only borrow one book at a time
______________________________________________________________________________________________

Day 2:
OCP
-> Open Closed Principle

Hands On:
1. Add a quantity property to Order
2. refactor the order calculator and order validator and the discount associated classes to handle the quantity
3. Add a new category for discount -> Furniture
4. Update wherever necessary
5. Incorporate Composite Discounts 

For the case study 
1. add NotificationFactory and refactor the services
2. Add a SlackNotificationService
3. Add a Premium Member. provide for reward points

Added practice
1. add ebook subclass
2. Update late fee calculation to handle different book types
3. Add categories for books (Academic and Non-academic) with different late fees and different number of days for return
4. Add a duedate extension service/ re-issue service

__________________________________________________________________________________________________________
Day 3:
LSP -> Liskov Substitution Principle
-> Barbara Liskov in the 1980s
-> polymorphism works correctly
-> code remain stable and reliable even when new implementations are introduced


Ex violating LSP

public class Rectangle {
	public int Height {get; set;}
	public int Width {get; set;}

	public int CalculateArea() => Height * Width;
}

public class Square : Rectangle {
	public override int Height {
		set 
		{
			base.Width = value;
			base.Height = value;
		}
	}
	public override int Width {
		set 
		{
			base.Width = value;
			base.Height = value;
		}
	}

}


public class Client {
	public void PrintArea(Rectangle rect) {
		rect.Width = 10;
		rect.Height = 20;
		Console.Writeline(rect.CalculateArea())
	}

	Main() {
		PrintArea(new Square());
	}

}

--------------------
LSP Compliant Code
public interface Shape {
	public int CalculateArea();
}

public class Rectangle : Shape {
}

public class Square : Shape {
}

Client{
	Main() {
		List<Shape> shapes = new List<Shape> {
			new Rectangle {},
			new Square {}
		}
	}
}

-----------------------------------------------------------

Hands On
1. Add LoyaltyDiscount - 5% off extra
2. Add InternationalShipping and SameDayShipping
3. calculate shipping amount based on weight and quantity
4. create a LimitedShippingService where if weight is beyond a certain value, it should switch to standard shipping

Case Study hands On
1. Add payment service with 4 services - Wallet, Credit, Debit, UPI
2. Add LoyaltyDiscount on the late fee
3. Add StaffMember. Loan duration = 15 days, late fee = 2/per day, should have an id field
4. Check for a suspended member. In case they try to borrow, display total late fee to be paid
5. Add a ReservedBook class. Send notification once a reserved book is returned
________________________________________________________________________________________________
Day 4:
ISP -> Interface Segregation Principle
-> keep interfaces small, focused and specific

Ex:
public interface IMachine // 'fat' interface
{
	void Print();
	void Scan();
	void Fax();
}

public class Scanner : IMachine
{
	void Scan() => Console.Writeline();
	void Print() => throw new NotImplementedException();
}
-----------------------
ISP Compliant:
public interface IPrinter{ void Print(); }

public interface IScanner { void Scan(); }

public class Scanner : IScanner {}


-----------------------------------------------------------------
Employee Management System
Entities: Employee (base), Developer, Manager, Tester etc (derived)
Behaviour: Work, Manage, Conduct interviews, Attend Meetings
Services: salary calculations, notifications, handle reporting

Hands on:
1. Add a new Class for HR
2. In EmployeeService, add a method PrintWorkReport. Call Work() polymorphically
3. Add a Reporting Service
4. Extend the salary calculation to add a role based bonus
5. Create a class for contract employee
6. Create a trainer role who only works and trains interns
7. Interns have to be trainable
-------------------------------------------------------------------------------------
Hands On:
Create a Vehicle Management System Project which incorporates SRP, OCP, LSP and ISP
1. Entities: Customer, Vehicle, Mechanic, Maintenance
2. Create the necessary repositories and services.
3. Add NotificationService
4. Add a new Mechanic Type. Example: Electrical mechanic
5. 
























